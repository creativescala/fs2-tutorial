<!doctype html>
<html lang="">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="Laika 1.0.0" />
    <title>k-Minimum Values</title>
    
    
    <meta name="description" content="docs" />
    
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600"
        rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Crimson+Pro:400" rel="stylesheet" type="text/css">
    <link rel="stylesheet" type="text/css" href="css/creative-scala.css" />
    <script src="js/toc.js"></script><script src="js/solution.js"></script><script src="main.js"></script>
    <script> /* for avoiding page load transitions */</script>
</head>

<body>
    <nav id="topbar">
      <details>
        <summary>FS2 Tutorial</summary>
        <ul class="nav-list">
          <li class="level1 nav-leaf"><a href="list.html">Stream as a List</a></li>
          <li class="level1 nav-leaf"><a href="time-and-effect.html">Effects over Time</a></li>
          <li class="level1 nav-leaf"><a href="pointillism.html">Pointillism</a></li>
          <li class="level1 nav-leaf"><a href="pull.html">Stages and Pulls</a></li>
          <li class="level1 active nav-leaf"><a href="#">k-Minimum Values</a></li>
          <li class="level1 nav-leaf"><a href="fan-in-out.html">Fan-in and Fan-out</a></li>
        </ul>
      </details>
    </nav>
    <nav id="sidebar">
        <ul class="nav-list">
          <li class="level1 nav-leaf"><a href="index.html">FS2 Tutorial</a></li>
          <li class="level1 nav-leaf"><a href="list.html">Stream as a List</a></li>
          <li class="level1 nav-leaf"><a href="time-and-effect.html">Effects over Time</a></li>
          <li class="level1 nav-leaf"><a href="pointillism.html">Pointillism</a></li>
          <li class="level1 nav-leaf"><a href="pull.html">Stages and Pulls</a></li>
          <li class="level1 active nav-leaf"><a href="#">k-Minimum Values</a></li>
          <li class="level1 nav-leaf"><a href="fan-in-out.html">Fan-in and Fan-out</a></li>
        </ul>
    </nav>

    <div id="content">
        <main class="content">
            <h1 id="k-minimum-values" class="title">k-Minimum Values</h1>
            <p>In this section we are diving into a relatively involved case study using FS2 in a typical application of data streaming: counting unique items. This allows us to explore practical usage of FS2 as well as learn about what you&#39;ll hopefully find a very interesting algorithm: <strong>k-Minimum Values</strong> (kMV).</p>
            <p>Our task is to estimate the number of <strong>distinct values</strong> in a data stream. That is, the number of values remaining if we remove all values that have already occurred. If we want to use fancy words, we can say we&#39;re estimating <strong>cardinality</strong>, which is the name of &quot;the number of elements in a set&quot;. This kind of problem arises very often in data analysis. Examples of distinct values problems in practice include calculating the number of unique visitors to a web site, or the number unique clients connecting to a network.</p>
            <p>Distinct value problems are easy to solve when the amount of data is small. In Scala we could just put all the data into a <code>Set</code> data structure and call the <code>size</code> method. However, there are situations where there is too much data, or it arrives too quickly, for this to work. Using a <code>Set</code> requires we store all the distinct values, which means the amount of memory used grows in direct proportion to number of distinct values. In the terminology of computational complexity we&#39;d say memory usage has order \(O(n)\), where \(n\) is the number of elements we observe. Similarly the time taken to insert an item into a <code>Set</code> is in the worst case proportional to \(log n\), so for \(n\) elements the total time is of order \(O(n log n)\).</p>
            <p>We can solve both our memory and time problems by using k-Minimum Values.
            k-Minimum Values is both a <strong>streaming algorithm</strong> and a <strong>sketch</strong>.
            A stream algorithm is one that requires only a single pass over the data, never needing to return data it has already seen.
            A sketch means we&#39;ll represent the data with some summary that takes dramatically less memory to store than the data itself.
            In the case of k-Minimum Values the amount of memory required is constant, with order \(O(k)\).
            These features come with a tradeoff: we will not get a exact answer, but only one that is close to correct with high probability.</p>
            
            <h2 id="a-sketch-of-k-minimum-values" class="section">A Sketch of k-Minimum Values</h2>
            <p>Let&#39;s start with an intuitive explanation of k-Minimum Values. Detailed mathematical analysis can be found in the references.</p>
            <p>Our task is to estimate the number of distinct elements in a data set. 
            Imagine that each element is a random number, uniformly distributed in the range \([0, 1]\). 
            Just one distinct element splits the range into two regions. 
            Two elements splits it into three regions, three elements into four regions, and so on. </p>
            <p>Let&#39;s now think about the average length of the regions. 
            With two regions (when there is one element) the average length is \(\frac{1}{2}\), as the sum of the lengths must be \(1\).
            With three regions it must be \(\frac{1}{3}\), with four regions \(\frac{1}{4}\), and so on.
            What this tells us is that the average length of the regions tells us how many distinct values there are, which is what we are trying to learn.
            Specifically, with \(n\) elements the average length of the regions is \(\frac{1}{n + 1}\).</p>
            <p>If we keep around <em>all</em> the elements we see we can get an exact measurement of the number of the elements from the average length of the regions.
            This is, however, a bit pointless. 
            Not only could we just count the number of elements directly, but what we&#39;re trying to do is explicitly <em>not</em> keep them all around.
            The leap that k-Minimum Values takes is to realize that the average length of a subset of the regions is a noisy estimate of the average length of all the regions, so we only need to keep around, say, \(k\) elements. 
            Which elements should we choose?
            We need to keep around a contiguous block, so that we correctly estimate the average length.
            The smallest \(k\) values will do.
            And there we have it: k-Minimum Values.</p>
            <p>So, in summary, k-Minimum Values works as follows:</p>
            <ol class="arabic">
              <li>We observe a stream of data uniformly distributed in the range \([0, 1]\).</li>
              <li>We keep the \(k\) smallest values we observe.</li>
              <li>We can estimate the total number of distinct element from the average length of the \(k\) regions between \(0\) and the largest value we keep.</li>
            </ol>
            <p>Does it actually work? 
            Below is an example where we draw 32 random values and keep only 16 of them (i.e. \(k\) is 16.)
            From the 16 samples we keep we estimate the total size. 
            You can reload the page a few times to see how the estimate changes.</p>
            <div class="doodle" id="number-line32"></div>
            <script>KMinimumValues.numberLine32("number-line32")</script>
            <p>For contrast, here&#39;s another example with \(k\) set to 16, and a total of 16384 values.
            As you can see all the minimum values are squooshed down at the left-hand side of the number line, and the estimation is still reasonably accurate..</p>
            <div class="doodle" id="number-line16384"></div>
            <script>KMinimumValues.numberLine16384("number-line16384")</script>
            <p>There is only one problem: we have assumed that elements are uniformly distributed in \([0, 1]\). 
            We won&#39;t be so lucky with real data.
            However there is a trick we can use: we can hash the data.
            A good hash function will give us a result that is uniformly distributed in the range of its output, which is typically 32-bits to 512-bits.
            For our purposes 32-bits will do, which will give us an integer we can convert to a fractional <code>Double</code> without loss of precision.
            In Scala we can use <a href="https://www.scala-lang.org/api/current/scala/util/hashing/MurmurHash3$.html#">scala.util.hashing.MurmurHash3</a>.</p>
            
            <h2 id="implementing-k-minimum-values" class="section">Implementing k-Minimum Values</h2>
            <p>We&#39;re going to implement a distinct values estimate system using k-Minimum Values.
            This means implementing the core algorithm as well as the support code around it that feeds it data. 
            This latter part is where FS2 will come in.</p>
            
            <h3 id="the-algorithm" class="section">The Algorithm</h3>
            <p>Your first mission is to implement the k-Minimum Values algorithm.
            There is a code skeleton in <code>code/src/main/scala/kmv/KMinimumValues.scala</code>.
            There are also simple tests in <code>code/src/test/scala/kmv/KMinimumValuesSuite.scala</code>.</p>
            <div class="solution">
              <div class="solution-body">
                <p>My solution uses a mutable array. I felt this like challenging myself to muck around with array indices and other concepts that I don&#39;t use much in my day-to-day programming. A solution using an immutable data structure would be a lot simpler to write.</p>
                <pre><code class="nohighlight"><span class="keyword">final</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">KMinimumValues</span><span>(</span><span class="identifier">k</span><span>: </span><span class="type-name">Int</span><span>) {
  </span><span class="comment">// The k minimum values, stored in a mutable array
</span><span>  </span><span class="keyword">private</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">values</span><span> = </span><span class="type-name">Array</span><span>.</span><span class="identifier">ofDim</span><span>[</span><span class="type-name">Double</span><span>](</span><span class="identifier">k</span><span>)

  </span><span class="comment">// Values will be initialized to contain all zeros, which will be less than
</span><span>  </span><span class="comment">// most reasonable input. Hence we need to track how many elements in values
</span><span>  </span><span class="comment">// have been initialized with real data.
</span><span>  </span><span class="keyword">private</span><span> </span><span class="keyword">var</span><span> </span><span class="identifier">used</span><span> = </span><span class="number-literal">0</span><span>

  </span><span class="keyword">def</span><span> </span><span class="declaration-name">add</span><span>(</span><span class="identifier">element</span><span>: </span><span class="type-name">Double</span><span>): </span><span class="type-name">KMinimumValues</span><span> = {
    </span><span class="keyword">import</span><span> </span><span class="identifier">java</span><span>.</span><span class="identifier">util</span><span>.</span><span class="type-name">Arrays</span><span>

    </span><span class="comment">// A +ve index indicates the element is in the array.
</span><span>    </span><span class="comment">//
</span><span>    </span><span class="comment">// A -ve index indicates the element is not in the array, and gives the
</span><span>    </span><span class="comment">// insertion point - 1 for the element.
</span><span>    </span><span class="comment">//
</span><span>    </span><span class="comment">// Only search in the elements of values that have been used
</span><span>    </span><span class="keyword">val</span><span> </span><span class="identifier">idx</span><span> = </span><span class="type-name">Arrays</span><span>.</span><span class="identifier">binarySearch</span><span>(</span><span class="identifier">values</span><span>, </span><span class="number-literal">0</span><span>, </span><span class="identifier">used</span><span>, </span><span class="identifier">element</span><span>)

    </span><span class="comment">// Element is already in the array
</span><span>    </span><span class="keyword">if</span><span> </span><span class="identifier">idx</span><span> &gt;= </span><span class="number-literal">0</span><span> </span><span class="identifier">then</span><span> </span><span class="keyword">this</span><span>
    </span><span class="keyword">else</span><span> {
      </span><span class="keyword">if</span><span> </span><span class="identifier">used</span><span> &lt; </span><span class="identifier">values</span><span>.</span><span class="identifier">size</span><span> </span><span class="identifier">then</span><span> </span><span class="identifier">used</span><span> = </span><span class="identifier">used</span><span> + </span><span class="number-literal">1</span><span>

      </span><span class="keyword">val</span><span> </span><span class="identifier">insertionPoint</span><span> = -</span><span class="identifier">idx</span><span> - </span><span class="number-literal">1</span><span>
      </span><span class="comment">// Element is larger than any existing value
</span><span>      </span><span class="keyword">if</span><span> </span><span class="identifier">insertionPoint</span><span> &gt;= </span><span class="identifier">values</span><span>.</span><span class="identifier">size</span><span> </span><span class="identifier">then</span><span> </span><span class="keyword">this</span><span>
      </span><span class="keyword">else</span><span> {
        </span><span class="comment">// Shift all the larger values out of the way and insert element
</span><span>        </span><span class="type-name">System</span><span>.</span><span class="identifier">arraycopy</span><span>(
          </span><span class="identifier">values</span><span>,
          </span><span class="identifier">insertionPoint</span><span>,
          </span><span class="identifier">values</span><span>,
          </span><span class="identifier">insertionPoint</span><span> + </span><span class="number-literal">1</span><span>,
          </span><span class="identifier">values</span><span>.</span><span class="identifier">size</span><span> - </span><span class="identifier">insertionPoint</span><span> - </span><span class="number-literal">1</span><span>
        )
        </span><span class="identifier">values</span><span>(</span><span class="identifier">insertionPoint</span><span>) = </span><span class="identifier">element</span><span>
        </span><span class="keyword">this</span><span>
      }
    }
  }

  </span><span class="keyword">def</span><span> </span><span class="declaration-name">distinctValues</span><span>: </span><span class="type-name">Long</span><span> =
    </span><span class="comment">// If we have seen fewer than k values we can return the exact number of
</span><span>    </span><span class="comment">// distinct values
</span><span>    </span><span class="keyword">if</span><span> </span><span class="identifier">used</span><span> &lt; </span><span class="identifier">values</span><span>.</span><span class="identifier">size</span><span> </span><span class="identifier">then</span><span> </span><span class="identifier">used</span><span>.</span><span class="identifier">toLong</span><span>
    </span><span class="keyword">else</span><span> </span><span class="type-name">Math</span><span>.</span><span class="identifier">round</span><span>(</span><span class="identifier">k</span><span>.</span><span class="identifier">toDouble</span><span> / </span><span class="identifier">values</span><span>.</span><span class="identifier">last</span><span> - </span><span class="number-literal">1.0</span><span>)
}</span></code></pre>
              </div>
            </div>
            
            <h3 id="building-a-data-pipeline" class="section">Building a Data Pipeline</h3>
            <p>We&#39;re now going to build the pipeline that will feed the k-Minimum Values algorithm.
            This will have the following stages:</p>
            <ul>
              <li>reading text from storage;</li>
              <li>segmenting the text into words; and</li>
              <li>hashing the words into <code>Double</code> values between 0 and 1.</li>
            </ul>
            <p>For all of these parts we will use FS2.</p>
            <p>For data we will use two sources:</p>
            <ol class="arabic">
              <li>
                <p>The 1934 version of Webster&#39;s Dictionary, now in the public domain. This file has one word per line, and every word is unique, so it gives us an easy way to test our algorithm.</p>
              </li>
              <li>
                <p>The complete works of William Shakespeare. This is much bigger than the dictionary, contains duplicates, and requires more processing, and so is a more realistic test.</p>
              </li>
            </ol>
            <p>Neither of our test cases are big enough that we really need to use k-Minimum Values; we could use a traditional algorithm instead. 
            This is intentional. 
            It is useful to be able to compare to a known correct result,
            and working with truly big data requires file sizes and processing times that are onerous.</p>
            
            <h4 id="reading-and-processing-text" class="section">Reading and Processing Text</h4>
            
            <h4 id="hashing-data" class="section">Hashing Data</h4>
            
            <h4 id="pipes" class="section">Pipes</h4>
            
            <h2 id="references" class="section">References</h2>
            <p><a href="http://www.vldb.org/pvldb/vol11/p499-harmouch.pdf">http://www.vldb.org/pvldb/vol11/p499-harmouch.pdf</a></p>
            <div class="flex flex-row justify-between">
                <a class="pageNavigation" href="pull.html">←Stages and Pulls</a> <a class="pageNavigation" href="fan-in-out.html">Fan-in and Fan-out→</a>
            </div>
        </main>
        <footer>Creative Scala is copyright Noel Welsh</footer>
    </div>

    </div>
</body>

</html>
