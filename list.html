<!doctype html>
<html lang="">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="Laika 1.0.0" />
    <title>Stream as a List</title>
    
    
    <meta name="description" content="docs" />
    
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600"
        rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Crimson+Pro:400" rel="stylesheet" type="text/css">
    <link rel="stylesheet" type="text/css" href="css/creative-scala.css" />
    <script src="js/toc.js"></script><script src="js/solution.js"></script><script src="main.js"></script>
    <script> /* for avoiding page load transitions */</script>
</head>

<body>
    <nav id="topbar">
      <details>
        <summary>FS2 Tutorial</summary>
        <ul class="nav-list">
          <li class="level1 active nav-leaf"><a href="#">Stream as a List</a></li>
          <li class="level1 nav-leaf"><a href="time-and-effect.html">Streams as Effects over Time</a></li>
          <li class="level1 nav-leaf"><a href="pointillism.html">Pointillism</a></li>
        </ul>
      </details>
    </nav>
    <nav id="sidebar">
        <ul class="nav-list">
          <li class="level1 nav-leaf"><a href="index.html">FS2 Tutorial</a></li>
          <li class="level1 active nav-leaf"><a href="#">Stream as a List</a></li>
          <li class="level1 nav-leaf"><a href="time-and-effect.html">Streams as Effects over Time</a></li>
          <li class="level1 nav-leaf"><a href="pointillism.html">Pointillism</a></li>
        </ul>
    </nav>

    <div id="content">
        <main class="content">
            <h1 id="stream-as-a-list" class="title">Stream as a List</h1>
            <p><code>Stream</code> is the main type in FS2. We&#39;re going to develop several mental models to understand how <code>Stream</code> works. We&#39;ll start with a really simple model: <code>Stream</code> is just a fancy <code>List</code>.</p>
            
            <h2 id="working-with-stream" class="section">Working With Stream</h2>
            <p>We can construct a <code>Stream</code> just like we&#39;d construct a <code>List</code>.</p>
            <pre><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">fs2</span><span>.*

</span><span class="keyword">val</span><span> </span><span class="identifier">s</span><span> = </span><span class="type-name">Stream</span><span>(</span><span class="number-literal">1</span><span>, </span><span class="number-literal">2</span><span>, </span><span class="number-literal">3</span><span>, </span><span class="number-literal">4</span><span>, </span><span class="number-literal">5</span><span>)
</span><span class="comment">// s: Stream[[x &gt;: Nothing &lt;: Any] =&gt; Pure[x], Int] = Stream(..)</span></code></pre>
            <p>As you can see from what is printed, it is indeed a fancy <code>List</code>.
            We have some odd type parameter, and it&#39;s so fancy that it doesn&#39;t print its value.</p>
            <p>We can see it does contain the values we expect by converting it to a <code>List</code>.</p>
            <pre><code class="nohighlight"><span class="identifier">s</span><span>.</span><span class="identifier">toList</span><span>
</span><span class="comment">// res0: List[Int] = List(1, 2, 3, 4, 5)</span></code></pre>
            <p>We can do the majority of the things we&#39;d do with a <code>List</code> with <code>Stream</code>.
            Here&#39;s another example.</p>
            <pre><code class="nohighlight"><span class="identifier">s</span><span>.</span><span class="identifier">map</span><span>(</span><span class="identifier">x</span><span> =&gt; </span><span class="identifier">x</span><span> + </span><span class="number-literal">1</span><span>).</span><span class="identifier">toList</span><span>
</span><span class="comment">// res1: List[Int] = List(2, 3, 4, 5, 6)</span></code></pre>
            <p>You don&#39;t need me to reiterate the <code>List</code> API here, as I&#39;m sure you&#39;re familiar with it.
            It&#39;s time for you to write some code. 
            Go and do the code exercise in <code>code/src/main/scala/introduction/01-list.scala</code>.</p>
            <div class="solution">
              <div class="solution-body">
                <p>Here&#39;s one way you could solve the problem. For several of the questions you could use different methods to achieve the same effect.</p>
                <pre><code class="nohighlight"><span class="keyword">object</span><span> </span><span class="type-name">StreamAsList</span><span> {
  </span><span class="comment">// Construction. We focus on creating Streams
</span><span>
  </span><span class="comment">// The empty stream produces no values
</span><span>  </span><span class="keyword">val</span><span> </span><span class="identifier">empty</span><span>: </span><span class="type-name">Stream</span><span>[</span><span class="type-name">Pure</span><span>, </span><span class="type-name">Int</span><span>] = 
    </span><span class="type-name">Stream</span><span>.</span><span class="identifier">empty</span><span>

  </span><span class="comment">// This Stream should produce 1, 2, and 3, in that order
</span><span>  </span><span class="keyword">val</span><span> </span><span class="identifier">naturals</span><span>: </span><span class="type-name">Stream</span><span>[</span><span class="type-name">Pure</span><span>, </span><span class="type-name">Int</span><span>] = 
    </span><span class="type-name">Stream</span><span>(</span><span class="number-literal">1</span><span>, </span><span class="number-literal">2</span><span>, </span><span class="number-literal">3</span><span>)

  </span><span class="comment">// This method accepts a single value and returns the Stream that produces
</span><span>  </span><span class="comment">// that single value
</span><span>  </span><span class="keyword">def</span><span> </span><span class="declaration-name">one</span><span>[</span><span class="type-name">A</span><span>](</span><span class="identifier">value</span><span>: </span><span class="type-name">A</span><span>): </span><span class="type-name">Stream</span><span>[</span><span class="type-name">Pure</span><span>, </span><span class="type-name">A</span><span>] = 
    </span><span class="type-name">Stream</span><span>.</span><span class="identifier">emit</span><span>(</span><span class="identifier">value</span><span>)

  </span><span class="comment">// This method accepts a list of values and returns the Stream that produces
</span><span>  </span><span class="comment">// exactly those values in the order given.
</span><span>  </span><span class="keyword">def</span><span> </span><span class="declaration-name">list</span><span>[</span><span class="type-name">A</span><span>](</span><span class="identifier">values</span><span>: </span><span class="type-name">List</span><span>[</span><span class="type-name">A</span><span>]): </span><span class="type-name">Stream</span><span>[</span><span class="type-name">Pure</span><span>, </span><span class="type-name">A</span><span>] = 
    </span><span class="type-name">Stream</span><span>.</span><span class="identifier">emits</span><span>(</span><span class="identifier">values</span><span>)

  </span><span class="comment">// Transformation. We focus on transforming existing Streams
</span><span>
  </span><span class="comment">// This method returns a stream where every element in `stream` is incremented
</span><span>  </span><span class="comment">// by `value`.
</span><span>  </span><span class="keyword">def</span><span> </span><span class="declaration-name">add</span><span>(</span><span class="identifier">stream</span><span>: </span><span class="type-name">Stream</span><span>[</span><span class="type-name">Pure</span><span>, </span><span class="type-name">Int</span><span>], </span><span class="identifier">value</span><span>: </span><span class="type-name">Int</span><span>): </span><span class="type-name">Stream</span><span>[</span><span class="type-name">Pure</span><span>, </span><span class="type-name">Int</span><span>] =
    </span><span class="identifier">stream</span><span>.</span><span class="identifier">map</span><span>(</span><span class="identifier">x</span><span> =&gt; </span><span class="identifier">x</span><span> + </span><span class="identifier">value</span><span>)

  </span><span class="comment">// This methods return a stream that only contains the values of the input
</span><span>  </span><span class="comment">// stream that match the predicate.
</span><span>  </span><span class="keyword">def</span><span> </span><span class="declaration-name">only</span><span>[</span><span class="type-name">A</span><span>](
      </span><span class="identifier">stream</span><span>: </span><span class="type-name">Stream</span><span>[</span><span class="type-name">Pure</span><span>, </span><span class="type-name">A</span><span>],
      </span><span class="identifier">predicate</span><span>: </span><span class="type-name">A</span><span> =&gt; </span><span class="type-name">Boolean</span><span>
  ): </span><span class="type-name">Stream</span><span>[</span><span class="type-name">Pure</span><span>, </span><span class="type-name">A</span><span>] = 
    </span><span class="identifier">stream</span><span>.</span><span class="identifier">filter</span><span>(</span><span class="identifier">predicate</span><span>)

  </span><span class="comment">// This method should sum all the values in the given `stream` and return a
</span><span>  </span><span class="comment">// Stream containing just a single value, the total.
</span><span>  </span><span class="keyword">def</span><span> </span><span class="declaration-name">sum</span><span>(</span><span class="identifier">stream</span><span>: </span><span class="type-name">Stream</span><span>[</span><span class="type-name">Pure</span><span>, </span><span class="type-name">Int</span><span>]): </span><span class="type-name">Stream</span><span>[</span><span class="type-name">Pure</span><span>, </span><span class="type-name">Int</span><span>] =
    </span><span class="identifier">stream</span><span>.</span><span class="identifier">fold</span><span>(</span><span class="number-literal">0</span><span>)((</span><span class="identifier">accum</span><span>, </span><span class="identifier">elt</span><span>) =&gt; </span><span class="identifier">accum</span><span> + </span><span class="identifier">elt</span><span>)
}</span></code></pre>
              </div>
            </div>
            
            <h2 id="streaming-algorithms-kahan-summation" class="section">Streaming Algorithms: Kahan Summation</h2>
            <p>We haven&#39;t yet seen what differentiates a <code>Stream</code> from a <code>List</code>, but we&#39;ve seen enough to look at our first streaming algorithm.
            This algorithm, known as Kahan summation, performs the apparently simple job of summing numbers.</p>
            <p>Floating point numbers are kinda goofy. One issue is that they have finite precision. This can lead to surprising results from simple arithmetic. Let&#39;s see an example with <code>Float</code>, instead of <code>Double</code>, as it&#39;s easier to see the problem with lower precision numbers.</p>
            <p>Here&#39;s one billion written as a <code>Float</code>. (Did you know you can use the <code>_</code> separator in Scala to write numbers? I didn&#39;t until recently. The <code>f</code> suffix makes the literal a <code>Float</code> instead of <code>Double</code>.)</p>
            <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">billion</span><span> = </span><span class="number-literal">1_000_000_000.0f</span><span>
</span><span class="comment">// billion: Float = 1.0E9F</span></code></pre>
            <p>Let&#39;s add 40,000 to it.</p>
            <pre><code class="nohighlight"><span class="identifier">billion</span><span> + </span><span class="number-literal">40_000f</span><span>
</span><span class="comment">// res2: Float = 1.00004E9F</span></code></pre>
            <p>Easy enough. Let&#39;s do the same in a roundabout way.</p>
            <pre><code class="nohighlight"><span>(</span><span class="identifier">billion</span><span> :: </span><span class="type-name">List</span><span>.</span><span class="identifier">fill</span><span>(</span><span class="number-literal">10_000</span><span>)(</span><span class="number-literal">4.0f</span><span>)).</span><span class="identifier">foldLeft</span><span>(</span><span class="number-literal">0.0f</span><span>)(</span><span class="identifier">_</span><span> + </span><span class="identifier">_</span><span>)
</span><span class="comment">// res3: Float = 1.0E9F</span></code></pre>
            <p>Hmmm. We are out by 40,000. This occurs because a <code>Float</code> can only store between 6 and 9 decimal digits of precision. As a result, one billion (represented as a <code>Float</code>) plus one rounds to one billion.</p>
            <pre><code class="nohighlight"><span class="number-literal">1_000_000_000f</span><span> + </span><span class="number-literal">1f</span><span>
</span><span class="comment">// res4: Float = 1.0E9F</span></code></pre>
            <p>There are three possible solutions: </p>
            <ol class="arabic">
              <li>we can use a higher precision numeric type;</li>
              <li>we can cry, because life is unfair;</li>
              <li>we can use a clever algorithm like <a href="https://en.wikipedia.org/wiki/Kahan_summation_algorithm">Kahan summation</a>. </li>
            </ol>
            <p>For this exercise we&#39;ll choose option 3.</p>
            <p>The <a href="https://en.wikipedia.org/wiki/Kahan_summation_algorithm">Wikipedia explanation</a> is clear enough that I&#39;m not going to repeat a description here. Implement Kahan summation in <code>code/src/main/scala/introduction/02-kahan.scala</code>.</p>
            <div class="solution">
              <div class="solution-body">
                <p>There are two parts to this. The first, harder, part is to implement Kahan summation itself. The second part is to remove the state that Kahan summation needs from the output of the <code>Stream</code>. Here&#39;s how I did it.</p>
                <pre><code class="nohighlight"><span class="keyword">object</span><span> </span><span class="type-name">Kahan</span><span> {
  </span><span class="keyword">final</span><span> </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">KahanSum</span><span>(</span><span class="identifier">total</span><span>: </span><span class="type-name">Float</span><span>, </span><span class="identifier">carry</span><span>: </span><span class="type-name">Float</span><span>) {
    </span><span class="keyword">def</span><span> +(</span><span class="identifier">input</span><span>: </span><span class="type-name">Float</span><span>): </span><span class="type-name">KahanSum</span><span> = {
      </span><span class="keyword">val</span><span> </span><span class="identifier">y</span><span> = </span><span class="identifier">input</span><span> - </span><span class="identifier">carry</span><span>
      </span><span class="keyword">val</span><span> </span><span class="identifier">nextTotal</span><span> = </span><span class="identifier">total</span><span> + </span><span class="identifier">y</span><span>
      </span><span class="keyword">val</span><span> </span><span class="identifier">nextCarry</span><span> = (</span><span class="identifier">nextTotal</span><span> - </span><span class="identifier">total</span><span>) - </span><span class="identifier">y</span><span>

      </span><span class="type-name">KahanSum</span><span>(</span><span class="identifier">nextTotal</span><span>, </span><span class="identifier">nextCarry</span><span>)
    }
  }
  </span><span class="keyword">object</span><span> </span><span class="type-name">KahanSum</span><span> {
    </span><span class="keyword">val</span><span> </span><span class="identifier">empty</span><span> = </span><span class="type-name">KahanSum</span><span>(</span><span class="number-literal">0.0f</span><span>, </span><span class="number-literal">0.0f</span><span>)
  }

  </span><span class="comment">// Perform Kahan summation, returning a Stream with a single element that is
</span><span>  </span><span class="comment">// the total
</span><span>  </span><span class="keyword">def</span><span> </span><span class="declaration-name">sum</span><span>(</span><span class="identifier">stream</span><span>: </span><span class="type-name">Stream</span><span>[</span><span class="type-name">Pure</span><span>, </span><span class="type-name">Float</span><span>]): </span><span class="type-name">Stream</span><span>[</span><span class="type-name">Pure</span><span>, </span><span class="type-name">Float</span><span>] =
    </span><span class="identifier">stream</span><span>.</span><span class="identifier">fold</span><span>(</span><span class="type-name">KahanSum</span><span>.</span><span class="identifier">empty</span><span>)((</span><span class="identifier">accum</span><span>, </span><span class="identifier">elt</span><span>) =&gt; </span><span class="identifier">accum</span><span> + </span><span class="identifier">elt</span><span>).</span><span class="identifier">map</span><span>(</span><span class="identifier">_</span><span>.</span><span class="identifier">total</span><span>)

  </span><span class="comment">// Perform Kahan summation, returning a Stream where each element is the sum
</span><span>  </span><span class="comment">// of elements in the input up to that point.
</span><span>  </span><span class="comment">//
</span><span>  </span><span class="comment">// This is often more useful in a streaming application because the input may
</span><span>  </span><span class="comment">// never end, or we may want the most up-to-date result at any given point in
</span><span>  </span><span class="comment">// time.
</span><span>  </span><span class="keyword">def</span><span> </span><span class="declaration-name">cumulativeSum</span><span>(</span><span class="identifier">stream</span><span>: </span><span class="type-name">Stream</span><span>[</span><span class="type-name">Pure</span><span>, </span><span class="type-name">Float</span><span>]): </span><span class="type-name">Stream</span><span>[</span><span class="type-name">Pure</span><span>, </span><span class="type-name">Float</span><span>] =
    </span><span class="identifier">stream</span><span>.</span><span class="identifier">scan</span><span>(</span><span class="type-name">KahanSum</span><span>.</span><span class="identifier">empty</span><span>)((</span><span class="identifier">accum</span><span>, </span><span class="identifier">elt</span><span>) =&gt; </span><span class="identifier">accum</span><span> + </span><span class="identifier">elt</span><span>).</span><span class="identifier">map</span><span>(</span><span class="identifier">_</span><span>.</span><span class="identifier">total</span><span>).</span><span class="identifier">tail</span><span>
}</span></code></pre>
              </div>
            </div>
            <div class="flex flex-row justify-between">
                <a class="pageNavigation" href="index.html">←FS2 Tutorial</a> <a class="pageNavigation" href="time-and-effect.html">Streams as Effects over Time→</a>
            </div>
        </main>
        <footer>Creative Scala is copyright Noel Welsh</footer>
    </div>

    </div>
</body>

</html>
